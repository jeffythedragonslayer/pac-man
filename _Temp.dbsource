Rem Project: Pac-Man
Rem Created: [date] [time]

Rem ***** Main Source File *****

`global arrays
dim chunk(2, 2) as dword
dim map(2, 2) as dword
initBMfonts()

`setup
sync on
sync rate 45
hide mouse
randomize timer()

main_menu()
Rem *** Include File: Free.dba ***
Rem Created: [date] [time]

Rem Included in Project: Pac-Man.dbpro

function free_img()
  local id as dword
  repeat
    inc id
  until image exist(id) = 0
endfunction id

function free_spr()
  local id as dword
  repeat
    inc id
  until sprite exist(id) = 0
endfunction id

function free_sound()
  local id as dword
  repeat
    inc id
  until sound exist(id) = 0
endfunction id

function free_file()
  local id as dword
  repeat
    inc id
    if id = 33
      id = 0
      exitfunction id
    endif
  until file open(id) = 0
endfunction id

function free_mem()
  local id as dword
  repeat
    inc id
  until memblock exist(id) = 0
endfunction id
Rem *** Include File: Game.dba ***
Rem Created: [date] [time]

Rem Included in Project: Pac-Man.dbpro

global game_inited as boolean

global img_pac as dword
global spr_pac as dword
global img_sdot as dword
global img_bdot as dword
global spr_fruit as dword
global spr_pac_die as dword
global img_pac_die as dword

global maze_rows as dword
global maze_columns as dword

global pos_ghost_pen as coordinate
global pos_pac_spawn as coordinate
global pos_message as coordinate

global pac_try as dword
global pac_dir as dword

global score as dword
global hiscore as dword
global level as dword
global lives as dword
global blue_ghosts as dword
global ghosts_eaten as dword

global bonus as boolean
global total_dots as dword

global spr_message as dword
global img_ready as dword
global img_game_over as dword

global snd_ready as dword
global snd_eat_fruit as dword
global snd_eat_dot as dword
global snd_eat_ghost as dword
global snd_bonus as dword
global snd_die as dword

global text_score as dword
global text_level as dword
global text_lives as dword

global cycle as dword

#constant move_speed = 2
#constant anim_speed = 75
#constant cycles = 8

type yum
  id as dword
  size as boolean
endtype

type fruit
  id as dword
  eaten as boolean
endtype

type wall
  id as dword
  solid as dword
  food as dword
endtype

type coordinate
  x as integer
  y as integer
endtype

type ghost
  id as dword
  direction as dword
endtype

`play the game
function play()

  `if menu is not already loaded, load it
  if game_inited = 0 then init_game()

  level_up()
  ready()
  game_loop()
  
endfunction

`move to the next level
function level_up()

  inc level
  make_dots()
  respawn_pac()
  respawn_ghosts()
  
  `make the fruit dissappear
  hide sprite spr_fruit
  
  break
  
  `update hud
  if text_level then BMFont(640, 96, "Level: " + str$(level), text_level, 0)

endfunction

`fill the board with dots
function make_dots()

  local x as dword
  local y as dword
  
  `check each tile
  for y = 1 to maze_rows
    for x = 1 to maze_columns
      
      `make a dot at this tile if there's supposed to be one
      if sprs_maze(x, y).food
        make_dot(sprs_maze(x, y).food - 1, x*32 + 16, y*32 + 16)
        
        `make dots halfway between tiles
        if sprs_maze(x+1, y).food
          make_dot(0, (x+1) * 32, y*32 + 16)
        endif
        if sprs_maze(x, y+1).food
          make_dot(0, x*32 + 16, (y+1) * 32)
        endif
      endif

    next x
  next y
  
  `count total dots
  total_dots = array count(sprs_dots(0)) + 1
   
endfunction

`make a dot
function make_dot(size as boolean, xpix as dword, ypix as dword)

  `make a new dot array slot
  array insert at bottom sprs_dots()
  
  `copy size argument into array
  sprs_dots().size = size

  `make dot sprite
  if size
    sprs_dots().id = make_spr(xpix, ypix, img_bdot)
  else
    sprs_dots().id = make_spr(xpix, ypix, img_sdot)
  endif
  
  `center dot on coordinates
  offset sprite sprs_dots().id, sprite width(sprs_dots().id) / 2, sprite height(sprs_dots().id) / 2

  `turn off backsave and transparency
  set sprite sprs_dots().id, 0, 0

endfunction

`place pac-man in the spawn area
function respawn_pac()

    sprite spr_pac, pos_pac_spawn.x*32, pos_pac_spawn.y*32, img_pac
    set sprite frame spr_pac, 1
    pac_dir = 0
       
endfunction

`place the ghosts in the ghost pen
function respawn_ghosts()     

  local ghost as dword

  for ghost = 0 to 4
    respawn_ghost(ghost)
  next ghost
  
endfunction

`place the ghost in the ghost pen
function respawn_ghost(ghost as dword)

  sprite sprs_ghosts(ghost).id, pos_ghost_pen.x*32, pos_ghost_pen.y*32, imgs_ghosts(ghost)
  set sprite alpha sprs_ghosts(ghost).id, 0

endfunction

`play the music and display "Ready" at the start of the game
function ready()

  lives = 3
  
  `display "Ready!"
  sprite spr_message, pos_message.x*32 - 30, pos_message.y*32 + 9, img_ready
  show sprite spr_message

  `reset text system
  DeleteTexts()
  text_score = NewText()
  text_level = NewText()
  text_lives = NewText()
  BMFont(640, 32, "Score: " + str$(score), text_score, 0)
  BMFont(640, 96, "Level: " + str$(level), text_level, 0)
  BMFont(640, 160, "Lives: " + str$(lives), text_lives, 0)
  
  `play fanfare
  play sound snd_ready
  
  `wait until fanfare is done
  while sound playing(snd_ready)
  
    cls
  
    sync
  
  endwhile
  
  `hide message sprite
  hide sprite spr_message
  
endfunction

`the game's main loop

function game_loop()

  do
  
    TEXT 0, 10, "HI"
  
    inc cycle
    if cycle > cycles then cycle = 1

    cls

    get_pac_move()
    get_ghost_move()

    move_pac()
    move_ghosts()

    collision()
    if lives = 0 then exitfunction
    
    text 0, 0, "Frames Per Second: " + str$(screen fps())

    sync

  loop

endfunction

`get player input
function get_pac_move()

  select pac_try
    case 0
      if upkey() then pac_try = 1
      if rightkey() then pac_try = 2
      if downkey() then pac_try = 3
      if leftkey() then pac_try = 4
    endcase
    case 1
      if upkey() = 0 then pac_try = 0
    endcase
    case 2
      if rightkey() = 0 then pac_try = 0
    endcase
    case 3
      if downkey() = 0 then pac_try = 0
    endcase
    case 4
      if leftkey() = 0 then pac_try = 0
    endcase
  endselect

endfunction

 `do ghost AI
function get_ghost_move()

  local xpos as dword
  local ypos as dword
  local row as dword
  local column as dword
  local ghost as dword
  local dim directions() as dword
  local justspawned as boolean
  local count as integer
  local element as dword
  local pacx as dword
  local pacy as dword
  local desired as dword
  local sign as integer
  local alpha as dword
  
  `cache Pac-Man position for AI calculation
  pacx = sprite x(spr_pac)/32
  pacy = sprite y(spr_pac)/32
  
  for ghost = 0 to 4
  
    `cache ghost position
    xpos = sprite x(sprs_ghosts(ghost).id)
    ypos = sprite y(sprs_ghosts(ghost).id)
    
    `find current tile ghost is in
    column = xpos/32
    row = ypos/32
    
    `only change direction if ghost is completely in a square
    if xpos/32.0 = column and ypos/32.0 = row
      
      `reset direction array
      empty array directions(0)
      count = -1
      
      `if ghost isn't fully spawned, don't allow any movement
      alpha = sprite alpha(sprs_ghosts(ghost).id)
      if alpha < 255
        if blue_ghosts = 0 then set sprite alpha sprs_ghosts(ghost).id, alpha + 1
      else
      
        `check to see if the ghost is standing on the spawn spot
        justspawned = 0
        if column = pos_ghost_pen.x and row = pos_ghost_pen.y then justspawned = 1
      
        `perform checklist for possible direction changes
        if sprs_maze(column, row-1).solid = 0 or (sprs_maze(column, row-1).solid = 2 and justspawned)
          array insert at bottom directions()
          directions() = 1
          inc count
        endif
        if sprs_maze(column+1, row).solid = 0 or (sprs_maze(column+1, row).solid = 2 and justspawned)
          array insert at bottom directions()
          directions() = 2
          inc count
        endif
        if sprs_maze(column, row+1).solid = 0 or (sprs_maze(column, row+1).solid = 2 and justspawned)
          array insert at bottom directions()
          directions() = 3
          inc count
        endif
        if sprs_maze(column-1, row).solid = 0 or (sprs_maze(column-1, row).solid = 2 and justspawned)
          array insert at bottom directions()
          directions() = 4
        inc count
        endif
      
        `if Pac-Man is visible, change start ghost going towards him
        if pacx = column or pacy = row
      
          `find direction needed to get to Pac-Man
          desired = 0
          if pacy < row then desired = 1
          if pacx > column then desired = 2
          if pacy > row then desired = 3
          if pacx < column then desired = 4
        
          `make ghost run away from Pac-Man if ghost is vulnerable
          if blue_ghosts and desired
            inc desired, 2
            if desired > 4 then dec desired, 4
          endif
        
          `make sure ghost isn't looking through walls
          if desired = 1 or desired = 3
            `check for clear pathways on y axis
            sign = sgn(pacy-row)
            for element = row to pacy step sign
              if sprs_maze(column, element).solid = 1
                `wall found, ghost cannot see Pac-Man
                desired = 0
                exit
              endif
            next element
          else
            `check for clear pathways on x axis
            sign = sgn(pacx-column)
            for element = column to pacx step sign
              if sprs_maze(element, row).solid = 1
                `wall found, ghost cannot see Pac-Man
                desired = 0
                exit
              endif
            next element
          endif
        
          `check if desired direction is allowed, if so delete all the others
          for element = 0 to count
            if directions(element) = desired
              empty array directions(0)
              array insert at top directions(0)
              directions() = desired
              count = 0
            endif
          next element
        
        endif
      
        `delete the direction the ghost just came from
        `to prevent the ghost from moving back and forth
        if count > 0
        
          `find and delete reversed direction
          for element = 0 to count
            if directions(element) = reverse_dir(sprs_ghosts(ghost).direction)
              array delete element directions(0), element
              dec count
              element = count
            endif
          next element
        
        endif
      
      endif
      
      `choose a direction from the checklist
      if count > -1
        sprs_ghosts(ghost).direction = directions(rnd(array count(directions(0))))
        move_ghost_animation(ghost)
      else
        sprs_ghosts(ghost).direction = 0
      endif
      
    endif
  
  next ghost

endfunction

`move pac-man
function move_pac()

  local xpos as dword
  local ypos as dword
  local row as dword
  local column as dword

  `cache Pac-Man position
  xpos = sprite x(spr_pac)
  ypos = sprite y(spr_pac)

  `find current tile Pac-Man is in
  column = xpos/32
  row = ypos/32
  
  `check if Pac-Man is completely in a tile
  if xpos/32.0 = column and ypos/32.0 = row
    `Pac-Man is completely in a square, now give player chance to change direction
    `if there's an open tile
    select pac_try
      case 1
        if sprs_maze(column, row-1).solid = 0
          pac_dir = 1
          move_pac_animation()
        endif
      endcase
      case 2
        if sprs_maze(column+1, row).solid = 0
          pac_dir = 2
          move_pac_animation()
        endif
      endcase
      case 3
        if sprs_maze(column, row+1).solid = 0
          pac_dir = 3
          move_pac_animation()
        endif
      endcase
      case 4
        if sprs_maze(column-1, row).solid = 0
          pac_dir = 4
          move_pac_animation()
        endif
      endcase
    endselect
    
    `stop Pac-Man from moving if he's about to walk into a wall
    select pac_dir
      case 1
        if sprs_maze(column, row-1).solid => 1
          pac_dir = 0
          move_pac_mouth()
        endif
      endcase
      case 2
        if sprs_maze(column+1, row).solid => 1
          pac_dir = 0
          move_pac_mouth()
        endif
      endcase
      case 3
        if sprs_maze(column, row+1).solid => 1
          pac_dir = 0
          move_pac_mouth()
        endif
      endcase
      case 4
        if sprs_maze(column-1, row).solid => 1
          pac_dir = 0
          move_pac_mouth()
        endif
      endcase
    endselect
    
  else
    if reverse_dir(pac_try) = pac_dir
      pac_dir = pac_try
      move_pac_animation()
    endif
  endif
  
  select pac_dir
    case 1
      dec ypos, move_speed
      play sprite spr_pac, 7, 8, anim_speed
    endcase
    case 2
      inc xpos, move_speed
      play sprite spr_pac, 1, 2, anim_speed
    endcase
    case 3
      inc ypos, move_speed
      play sprite spr_pac, 3, 4, anim_speed
    endcase
    case 4
      dec xpos, move_speed
      play sprite spr_pac, 5, 6, anim_speed
    endcase
  endselect
  
  sprite spr_pac, xpos, ypos, img_pac
  
endfunction

`set correct animation frame when Pac-Man changes direction
function move_pac_animation()

  select pac_dir
    case 1
      set sprite frame spr_pac, 7
    endcase
    case 2
      set sprite frame spr_pac, 1
    endcase
    case 3
      set sprite frame spr_pac, 3
    endcase
    case 4
      set sprite frame spr_pac, 5
    endcase
  endselect

endfunction

`make Pac-Man close his mouth
function move_pac_mouth()

  local frame as dword
  
  frame = sprite frame(spr_pac)
  if frame/2 = frame/2.0 then set sprite frame spr_pac, frame - 1
  
endfunction

`move ghosts
function move_ghosts()

  local xpos as dword
  local ypos as dword
  local ghost as dword
  local speed as dword
  
  `if ghosts are blue, slow them down
  if blue_ghosts
    speed = move_speed/2
  else
    speed = move_speed
  endif

  for ghost = 0 to 4

    `cache ghost position
    xpos = sprite x(sprs_ghosts(ghost).id)
    ypos = sprite y(sprs_ghosts(ghost).id)
  
    select sprs_ghosts(ghost).direction
      case 1
        dec ypos, speed
        play sprite sprs_ghosts(ghost).id, 7, 8, anim_speed
      endcase
      case 2
        inc xpos, speed
        play sprite sprs_ghosts(ghost).id, 1, 2, anim_speed
      endcase
      case 3
        inc ypos, speed
        play sprite sprs_ghosts(ghost).id, 3, 4, anim_speed
      endcase
      case 4
        dec xpos, speed
        play sprite sprs_ghosts(ghost).id, 5, 6, anim_speed
      endcase
    endselect
  
    sprite sprs_ghosts(ghost).id, xpos, ypos, imgs_ghosts(ghost)
    
  next ghost

endfunction

`set correct animation frame when ghost changes direction
function move_ghost_animation(ghost as dword)

  select sprs_ghosts(ghost).direction
    case 1
      set sprite frame sprs_ghosts(ghost).id, 7
    endcase
    case 2
      set sprite frame sprs_ghosts(ghost).id, 1
    endcase
    case 3
      set sprite frame sprs_ghosts(ghost).id, 3
    endcase
    case 4
      set sprite frame sprs_ghosts(ghost).id, 5
    endcase
  endselect

endfunction

`do collision
function collision()

  local xpos as integer
  local ypos as integer
  local dots as dword
  local num as dword
  local ghost as dword
  local dim xghost(4) as integer
  local dim yghost(4) as integer
  
  xpos = sprite x(spr_pac)
  ypos = sprite y(spr_pac)

  `maze wrapping
  `check if Pac-Man is out of bounds
  if xpos < 32 then xpos = maze_columns * 32
  if xpos > maze_columns * 32 then xpos = 32
  if ypos < 32 then ypos = maze_rows * 32
  if ypos > maze_rows * 32 then ypos = 32

  sprite spr_pac, xpos, ypos, img_pac
  
  inc xpos, 16
  inc ypos, 16
  
  `check if ghost is out of bounds
  for ghost = 0 to 4
  
    xghost(ghost) = sprite x(sprs_ghosts(ghost).id)
    yghost(ghost) = sprite y(sprs_ghosts(ghost).id)
    
    if xghost(ghost) < 32 then xghost(ghost) = maze_columns * 32
    if xghost(ghost) > maze_columns * 32 then xghost(ghost) = 32
    if yghost(ghost) < 32 then yghost(ghost) = maze_rows * 32
    if yghost(ghost) > maze_rows * 32 then yghost(ghost) = 32
    
    sprite sprs_ghosts(ghost).id, xghost(ghost), yghost(ghost), imgs_ghosts(ghost+1)
    
    inc xghost(ghost), 16
    inc yghost(ghost), 16
  
  next ghost
  
  `ghosts and Pac-Man eat each other
  if blue_ghosts
    `eat ghosts
    
    `decrement blue ghost timer
    dec blue_ghosts
    
    `if blue ghost timer hasn't run out, do Pac-Man eating ghost collision
    `otherwise make ghosts invincible again
    if blue_ghosts
      `do eat ghost collision    
      for ghost = 0 to 4
        `calculate Manhattan distance between Pac-Man and ghost
        if manhattan(xghost(ghost), yghost(ghost), xpos, ypos) <= 27
          eat_ghost(ghost)
          exit
        endif
      next ghost
      
    else      
      invinciblize_ghosts()
    endif
    
  else
    `get eaten
    
    for ghost = 0 to 4
      `calculate Manhattan distance between Pac-Man and ghost
      if manhattan(xghost(ghost), yghost(ghost), xpos, ypos) <= 27
        get_eaten()
        if lives = 0 then exitfunction
        exit
      endif
    next ghost
    
  endif
  
  `eat dots
  if cycle = 1
    dots = array count(sprs_dots(0))
    for num = 0 to dots
      `calculate Manhattan distance between Pac-Man and dot
      if manhattan(sprite x(sprs_dots(num).id), sprite y(sprs_dots(num).id), xpos, ypos) <= 14
        eat_dot(num)
        if dots = 0 then level_up()
        exit
      endif
    next num
  endif
  
  `eat fruits
  `calculate Manhattan distance between Pac-Man and fruit
  if manhattan(pos_message.x*32 + sprite width(spr_fruit)/2, pos_message.y*32 + sprite height(spr_fruit)/2, xpos, ypos) <= 14 then eat_fruit()
  
endfunction

`eat a ghost
function eat_ghost(ghost as dword)
  
  `play ghost eating sound
  play sound snd_eat_ghost
  
  `respawn ghost
  respawn_ghost(ghost)
  
  `give points
  inc ghosts_eaten
  inc_score(100*2^ghosts_eaten)
  
endfunction

`make ghosts return to normal color
function invinciblize_ghosts()

  local ghost as dword
  
  for ghost = 0 to 4
    set sprite image sprs_ghosts(ghost).id, imgs_ghosts(ghost+1)
  next ghost
  
  `reset amount of ghosts eaten
  ghosts_eaten = 0

endfunction

`Pac-Man gets eaten
function get_eaten()

  `play die sound
  play sound snd_die
  
  `setup die animation
  hide sprite spr_pac
  show sprite spr_pac_die
  sprite spr_pac_die, sprite x(spr_pac), sprite y(spr_pac), img_pac_die
  set sprite frame spr_pac_die, 1
  
  `play die animation
  while sound playing(snd_die)
  
    cls
  
    `if the last frame hasn't been reached yet, keep playing the animation
    if sprite frame(spr_pac_die) < 10 then play sprite spr_pac_die, 1, 10, 100
    
    sync
    
  endwhile
  
  
  `clean up die animation
  hide sprite spr_pac_die
  show sprite spr_pac  
  
  `take away a life
  dec lives
  
  `update hud
  BMFont(640, 160, "Lives: " + str$(lives), text_lives, 0)
      
  if lives = 0
    game_over()
    exitfunction
  endif
  
  `respawn Pac-Man and ghosts
  respawn_pac()
  respawn_ghosts()
  
endfunction

`display "Game Over" sprite
function game_over()

  local starttimer as dword
  
  `hide fruit sprite
  hide sprite spr_fruit

  `display sprite
  sprite spr_message, pos_message.x*32 - 51, pos_message.y*32 + 9, img_game_over
  show sprite spr_message
  
  `wait a few seconds
  starttimer = timer() + 2000
  repeat
  
    cls
    
    sync
    
  until timer() => starttimer or spacekey()
  
endfunction

`increment score
function inc_score(points as dword)

  `give points
  inc score, points

  `give bonus life
  if score >= 10000
    if bonus = 0
      inc lives
      bonus = 1
      
      `play bonus life sound
      play sound snd_bonus
      
      break
      
      `update hud
      BMFont(640, 96, "Lives: " + str$(lives), text_lives, 0)
      
    endif
  endif
  
  `update hud
  BMFont(640, 32, "Score: " + str$(score), text_score, 0)
  
endfunction

`eat a fruit
function eat_fruit()

  local fruit as dword
  local points as dword

  `Pac-Man can't eat a fruit if it doesn't exist
  if sprite visible(spr_fruit) = 0 then exitfunction
  
  `make the fruit dissappear
  hide sprite spr_fruit
  
  `record that the current fruit has been eaten
  for fruit = 0 to 11
    if imgs_fruits(fruit).id = sprite image(spr_fruit)
      imgs_fruits(fruit).eaten = 1
      exit
    endif
  next fruit
  
  `award points
  if level => 12
    points = 30000
  else
    restore fruit_points
    for fruit = 1 to level
      read points
    next fruit
  endif
  
  inc_score(points)
  
  `play fruit eating sound
  play sound snd_eat_fruit
  
endfunction

`eats a dot
function eat_dot(num as dword)

  local dots as dword

  `delete dot sprite
  delete sprite sprs_dots(num).id
  
  `increment score
  if sprs_dots(num).size
    `Pac-Man ate a big dot, give 50 points and turn ghosts blue
    inc_score(50)
    vulnerablize_ghosts(450)
  else
    `Pac-Man ate a small dot, give 10 points
    inc_score(10)
  endif
  
  `delete array slot
  array delete element sprs_dots(0), num
  
  `check if enough dots have been eaten to reward the player with a fruit
  dots = array count(sprs_dots(0)) + 1
  if dots = total_dots / 3 or dots = (total_dots/3)*2 then make_fruit()
  
  `play dot eating sound
  play sound snd_eat_dot
  
endfunction

`make ghosts blue and vulnerable
function vulnerablize_ghosts(timelimit as integer)

  local ghost as dword
  
  `start the blue ghost countdown
  blue_ghosts = timelimit
  
  `change each ghost's image to blue
  for ghost = 0 to 4
    set sprite image sprs_ghosts(ghost).id, imgs_ghosts(0)
  next ghost
  
endfunction

`make a fruit appear
function make_fruit()

  local fruit as dword
  local dim rnd_fruit() as dword

  `don't make a fruit if the current one hasn't been eaten
  if sprite visible(spr_fruit) then exitfunction
  
  `find which fruits haven't been eaten yet
  for fruit = 0 to 11
    if imgs_fruits(fruit).eaten = 0
      array insert at bottom rnd_fruit(0)
      rnd_fruit() = fruit
    endif
  next fruit
  
  `if all fruits have been eaten get new fruits
  if array count(rnd_fruit(0)) = -1
  
    `refresh fruits
    for fruit = 0 to 11
      imgs_fruits(fruit).eaten = 0
    next fruit
    
    `pick first fruit at random
    fruit = rnd(11)
    
  else

    `pick a fruit at random from the list of available fruits
    fruit = rnd_fruit(rnd(array count(rnd_fruit(0))))
    
  endif
  
  `display fruit
  set sprite image spr_fruit, imgs_fruits(fruit).id
  show sprite spr_fruit

endfunction

fruit_points:

data 100
data 300
data 500
data 700
data 1000
data 2000
data 3000
data 5000
data 7000
data 10000
data 20000
Rem *** Include File: Init Game.dba ***
Rem Created: [date] [time]

Rem Included in Project: Pac-Man.dbpro

`load the game
function init_game()

  set dir "Media"

    load_media()
    get_maze_data()
    position_maze()

  set dir ".."

  game_inited = 1

endfunction

`load the game images and make sprites
function load_media()
  
  load_maze()
  load_misc()
  load_pac()
  load_fruits()
  load_sounds()
  load_ghosts()
  
endfunction

function load_sounds()

  snd_ready = load_sound("Ready.wav")
  snd_eat_fruit = load_sound("Eat Fruit.wav")
  snd_eat_dot = load_sound("Eat Dot.wav")
  snd_eat_ghost = load_sound("Eat Ghost.wav")
  snd_bonus = load_sound("Bonus.wav")
  snd_die = load_sound("Die.wav")
  
endfunction

function load_pac()

  `load Pac-Man
  img_pac = free_img()
  spr_pac = free_spr()
  create animated sprite spr_pac, "Pac-Man.png", 2, 4, img_pac
  set sprite priority spr_pac, 2
  set sprite spr_pac, 0, 1
  
  `load Pac-Man die animation
  img_pac_die = free_img()
  spr_pac_die = free_spr()
  create animated sprite spr_pac_die, "Pac-Man die.png", 5, 2, img_pac_die
  set sprite priority spr_pac_die, 2
  set sprite spr_pac_die, 0, 1
  
endfunction

function load_ghosts()

  local img_ptr as dword
  dim imgs_ghosts(5) as dword
  dim sprs_ghosts(4) as ghost

  `load blue ghost image
  imgs_ghosts(0) = load_img("Blue Ghost.png", 1)
  
  for img_ptr = 0 to 4
    
    `load ghost image and sprite
    imgs_ghosts(img_ptr+1) = free_img()
    sprs_ghosts(img_ptr).id = free_spr()
    create animated sprite sprs_ghosts(img_ptr).id, "Ghost " + str$(img_ptr+1) + ".png", 2, 4, imgs_ghosts(img_ptr+1)
    set sprite priority sprs_ghosts(img_ptr).id, 2
    set sprite sprs_ghosts(img_ptr).id, 0, 1
    
    `paste another blue ghost image
    if img_ptr < 4 then paste image imgs_ghosts(0), 0, img_ptr*32
    
  next img_ptr
  
  `get blue ghost image at full size
  imgs_ghosts(0) = get_img(0, 0, 64, 128, 1)

endfunction

function load_fruits()

  local img_fruit as dword
  local img_ptr as dword
  dim imgs_fruits(11) as fruit

  `load the fruits
  img_fruit = load_img("Fruits.png", 1)
  paste image img_fruit, 0, 0
  
  `get the fruit images from the pasted image
  for ypix = 0 to 95 step 32
    for xpix = 0 to 127 step 32
    
      `capture the 32*32 image at these coordinates
      imgs_fruits(img_ptr).id = get_img(xpix, ypix, xpix+32, ypix+32, 1)
      
      `move the fruit image poiunter
      inc img_ptr
      
    next xpix
  next ypix
  
  `we're done with Fruits.png
  delete image img_fruit
  
endfunction

function load_maze()

  local xpix as dword
  local ypix as dword
  local img_maze as dword
  local img_ptr as dword
  dim imgs_maze(28) as dword

  img_maze = load_img("Maze.png", 1)
  paste image img_maze, 0, 0

  `get the maze images from the pasted image
  for ypix = 0 to 159 step 32
    for xpix = 0 to 191 step 32

      `skip the blank
      if img_ptr < 29

        `capture the 32*32 image at these coordinates
        imgs_maze(img_ptr) = get_img(xpix, ypix, xpix+32, ypix+32, 1)

        `move the current wall image pointer
        inc img_ptr

      endif

    next xpix
  next ypix

  `we're done with Maze.png
  delete image img_maze

endfunction

function load_misc()

  dim sprs_dots() as yum

  `load dot images
  img_bdot = load_img("Bdot.png", 1)
  img_sdot = load_img("Sdot.png", 1)
  
  `load "Ready!" image
  img_ready = load_img("Ready.png", 1)
  
  `load "Game Over" image
  img_game_over = load_img("Game Over.png", 1)
  
  `load the bitmap font
  loadBMfont("PacMania.png")
  TrimBMfont()
  
endfunction

`get the maze data from a file
function get_maze_data()

  local file_maze as dword
  local str as string
  local row as dword
  local column as dword

  `open maze file
  file_maze = open_to_read("Maze.map")

  `get maze dimensions
  read string file_maze, str
  csv$(str)
  maze_columns = val(csv$(""))
  maze_rows = val(csv$(""))

  `create maze array
  dim sprs_maze(maze_columns + 1, maze_rows + 1) as wall

  `load maze array data
  for row = 1 to maze_rows

    `read entire row
    read string file_maze, str

    for column = 1 to maze_columns
  
      `select type of tile
      select mid$(str, column)
        case "#"
          `wall
          sprs_maze(column, row).solid = 1
        endcase
        case "."
          `small dot
          sprs_maze(column, row).food = 1
        endcase
        case "*"
          `big dot
          sprs_maze(column, row).food = 2
        endcase
        case "G"
          `ghost gate
          sprs_maze(column, row).solid = 2
        endcase
        case "P"
          `ghost pen area
          pos_ghost_pen.x = column
          pos_ghost_pen.y = row
        endcase
        case "S"
          `Pac-Man spawn point
          pos_pac_spawn.x = column
          pos_pac_spawn.y = row                         
        endcase
        case "W"

          `wrap point
          sprs_maze(column, row).solid = 1

          `change the maze tile adjacent to this tile's solid state to 1
          if row = 1
            `upper tile needs to be set
            sprs_maze(column, 0).solid = 1
          else
            if row = maze_rows
              `lower tile needs to be set
              sprs_maze(column, maze_rows + 1).solid = 1
            else
              if column = 1
                `left tile needs to be set
                sprs_maze(0, row).solid = 1
              else
                if column = maze_columns
                  `right tile needs to be set
                  sprs_maze(maze_columns + 1, row).solid = 1
                endif
              endif
            endif
          endif

        endcase
        case "R"
          `message point
          pos_message.x = column
          pos_message.y = row
        
          `make message sprite
          spr_message = make_spr(0, 0, img_ready)
          set sprite spr_message, 0, 0
          set sprite priority spr_message, 2
          
          `make fruits sprite
          spr_fruit = make_spr(column*32, row*32, imgs_fruits(0).id)
          hide sprite spr_fruit
          set sprite priority spr_fruit, 1
          set sprite spr_fruit, 0, 0
          
        endcase
      endselect
  
    next column

  next row

  `close the map file
  close file file_maze

endfunction

`make and position the maze sprites using the data collected from get_maze_data()
function position_maze()

  local column as dword
  local row as dword
  local img_ptr as dword

  for row = 1 to maze_rows
    for column = 1 to maze_columns

      `select image
      select sprs_maze(column, row).solid
        case 0
          img_ptr = 11
        endcase
        case 1
          img_ptr = pick_img(column, row)
        endcase
        case 2
          img_ptr = 27
        endcase
      endselect

      `make sprite for this tile
      sprs_maze(column, row).id = make_spr(column * 32, row * 32, imgs_maze(img_ptr))

      `turn off backsave and transparency
      set sprite sprs_maze(column, row).id, 0, 0

    next column
  next row
  
endfunction

`decide which wall piece goes in the location given by the parameters
function pick_img(column as dword, row as dword)

  local img as dword
  local x as dword
  local y as dword
  local try as dword
  local cell as dword
  local pass as boolean
  
  `copy the maze solid data into a chunk of memory for easier access
  for x = 0 to 2
    for y = 0 to 2
      chunk(x, y) = sprs_maze(column + x - 1, row + y - 1).solid
    next y
  next x  
  
  `go back to the beginning of the data
  restore pick_imgs
  
  `try each map
  for try = 1 to tries
  
    `map matches by default
    pass = 1
    
    `copy the map solid data into the map chunk
    for cell = 0 to 8
    
      `read cell data
      read map(cell)
      
      `compare it with the maze data if it isn't the middle square
      `if map doesn't match set passing variable to 
      if cell <> 4 and map(cell) <> 3 and map(cell) <> chunk(cell) then pass = 0
      
    next cell
    
    if pass
      `map matches
      img = map(4)
      exitfunction img
    endif
    
  next try
  
  `no matching piece found
  img = 4
  
endfunction img

pick_imgs:
#constant tries = 27

data 3, 1, 1
data 0, 0, 1
data 3, 1, 1

data 0, 0, 3
data 1, 1, 0
data 1, 1, 0

data 3, 0, 3
data 0, 2, 1
data 3, 0, 3

data 3, 0, 3
data 1, 3, 1
data 0, 1, 0

data 1, 1, 1
data 1, 4, 1
data 1, 1, 1

data 3, 0, 3
data 1, 5, 0
data 0, 1, 3

data 3, 0, 3
data 1, 6, 1
data 1, 1, 1

data 1, 1, 0
data 1, 7, 0
data 0, 0, 3

data 3, 0, 3
data 0, 8, 0
data 3, 1, 3

data 3, 1, 3
data 0, 9, 0
data 3, 1, 3

data 3, 0, 3
data 0, 10, 0
data 3, 0, 3

data 1, 1, 3
data 1, 12, 0
data 1, 1, 3

data 0, 1, 1
data 0, 13, 1
data 3, 0, 0

data 3, 1, 0
data 0, 14, 1
data 3, 1, 0

data 0, 1, 0
data 1, 15, 1
data 0, 1, 0

data 3, 0, 3
data 1, 16, 1
data 3, 0, 3

data 0, 1, 3
data 1, 17, 0
data 0, 1, 3

data 1, 1, 1
data 1, 18, 1
data 3, 0, 3

data 3, 0, 0
data 0, 19, 1
data 0, 1, 1

data 3, 1, 0
data 0, 20, 1
data 3, 0, 3

data 0, 1, 0
data 1, 21, 1
data 3, 0, 3

data 3, 0, 3
data 1, 22, 0
data 3, 0, 3

data 3, 1, 3
data 0, 23, 0
data 3, 0, 3

data 0, 1, 3
data 1, 24, 0
data 3, 0, 3

data 3, 0, 3
data 0, 25, 1
data 3, 1, 0

data 3, 0, 3
data 1, 26, 2
data 3, 0, 3

data 3, 0, 3
data 2, 28, 1
data 3, 0, 3
Rem *** Include File: Media Allocate.dba ***
Rem Created: [date] [time]

Rem Included in Project: Pac-Man.dbpro

function load_img(filename as string, textureflag as boolean)
  local id as dword
  id = free_img()
  load image filename, id, textureflag
endfunction id

function get_img(left as dword, top as dword, right as dword, bottom as dword, textureflag as boolean)
  local id as dword
  id = free_img()
  get image id, left, top, right, bottom, textureflag
endfunction id

function load_sound(filename as string)
  local id as dword
  id = free_sound()
  load sound filename, id
endfunction id

function make_spr(xpos as dword, ypos as dword, img as dword)
  local id as dword
  id = free_spr()
  sprite id, xpos, ypos, img
endfunction id

function open_to_read(filename as string)
  local id as dword
  id = free_file()
  open to read id, filename
endfunction id

function open_to_write(filename as string)
  local id as dword
  id = free_file()
  open to write id, filename
endfunction id
Rem *** Include File: Menu.dba ***
Rem Created: [date] [time]

Rem Included in Project: Pac-Man.dbpro

global menu_inited as boolean

`run the main menu
function main_menu()

  `if menu is not already loaded, load it
  if menu_inited = 0 then init_menu()

  `*** Temporary Code ***
  `play the game
  play()
  `*** Temporary Code ***

  `menu loop
  do
    `get user selection
    `process user selection
  loop

endfunction

`load the menu's images and sprites
function init_menu()

  menu_inited = 1

endfunction
Rem *** Include File: Number.dba ***
Rem Created: [date] [time]

Rem Included in Project: Pac-Man.dbpro

`returns the sign of a number
`update 11:34 AM 9/13/2008, DBPro now supports sgn function
remstart
function sgn(num as integer)

  local sign as integer

  if num > 0
    sign = 1
  else
    if num
      sign = -1
    else
      sign = 0
    endif
  endif

endfunction sign
remend

`returns the opposite direction
function reverse_dir(direction as dword)
  
  if direction
    inc direction, 2
    if direction > 4 then dec direction, 4
  endif
  
endfunction direction

`returns the Manhattan distance between 2 points
function manhattan(x1 as integer, y1 as integer, x2 as integer, y2 as integer)

  local distance as dword
  
  distance = abs(x1 - x2) + abs(y1 - y2)

endfunction distance
Rem *** Include File: String.dba ***
Rem Created: [date] [time]

Rem Included in Project: Pac-Man.dbpro

global csv_start as dword
global csv_values as string

`extracts individual values from a comma separated values string
function csv$(called_values as string)

  local count as dword
  local return_value as string

  `if the function was called with values, replace the saved values
  if called_values <> ""
    csv_values = called_values
    csv_start = 1
    exitfunction ""
  endif

  `if all the tokens have been taken return end of string
  if csv_start > len(csv_values) then exitfunction "END OF STRING"

  `look for a comma
  for count = csv_start to len(csv_values)

    `if the character's a comma, return the token
    if mid$(csv_values, count) = ","
      return_value = right$(left$(csv_values, count - 1), count - csv_start)
      csv_start = count + 1
      exitfunction return_value
    endif

  next count

  `no comma found, so return last token
  return_value = right$(csv_values, count - csv_start)
  csv_start = count

endfunction return_value
Rem *** Include File: BMF.dba ***
Rem Created: [date] [time]

Rem Included in Project: Pac-Man.dbpro

global texts as integer
global chars as integer

function initBMfonts()

  Dim BMleft(127)
  Dim BMwidth(127)
  dim FontImageNumber(131) as dword
  dim BMSprites(,) as dword
  
  texts = -1
  chars = -1

endfunction

`*********************************
`       LOAD BITMAP FONT
`*********************************
Function LoadBMfont(FileName as string)

  FontImageNumber(0) = load_img(FileName, 1)
  Font = 32
  For y = 0 to 9
    for x = 0 to 9
      GetImage(Font, x*64, y*64, 64, 64 )
      inc Font
    next x
  next y
  Delete Image FontImageNumber(0)

endfunction

`*********************************
`   GET IMAGE WITH TRANSPARENCY
`*********************************
function GetImage(NewImage,Xstart,Ystart,Xsize as dword,Ysize as dword)

  `Set up variables
  Local Width as Dword
  Local Height as Dword
  Local Depth as Dword
  Local Red as Byte
  Local Green as Byte
  Local Blue as Byte
  Local Alpha as Byte

  `Do it!
  Memblock1 = free_mem()
  make memblock from image Memblock1,FontImageNumber(0)
  Width = memblock dword(Memblock1,0)
  Height = memblock dword(Memblock1,4)
  Depth = memblock dword(Memblock1,8)
  NewMemblock = free_mem()
  make memblock NewMemblock,(Width*Height)+12

  Write memblock Dword NewMemblock,0,Xsize
  Write memblock Dword NewMemblock,4,Ysize
  Write memblock Dword NewMemblock,8,Depth

  Position = (Width  * (Ystart)*4) + (Xstart*4) + 12
  NewPosition = 12

  for y = 1 to Ysize
    for x = 1 to Xsize

        Blue = memblock byte(Memblock1,Position)
        Green = memblock byte(Memblock1,Position+1)
        Red = memblock byte(Memblock1,Position+2)
        Alpha = memblock byte(Memblock1, Position+3)

        write memblock byte NewMemblock,NewPosition,Blue
        write memblock byte NewMemblock,NewPosition+1,Green
        write memblock byte NewMemblock,NewPosition+2,Red
        write memblock byte NewMemblock,NewPosition+3,Alpha

        inc Position,4
        inc NewPosition,4

    next x
    inc Position , (width*4) - (Xsize*4)
  next y

  FontImageNumber(NewImage) = free_img()
  make image from memblock FontImageNumber(NewImage),NewMemblock
  delete memblock Memblock1
  delete memblock NewMemblock

endfunction

`*********************************
`       TRIM BITMAP FONT
`*********************************
Function TrimBMFont()

  Local BlankColumn as boolean
  Local Alpha as byte
  Local Chr as integer
  Local FontWidth as integer = 64
  Local FontHeight as integer = 64
  
  local TrimMemblock as dword

  TrimMemblock = free_mem()

  For Chr = 33 to 126
    Make Memblock From Image 1 , FontImageNumber(Chr)
    for x = 1 to FontWidth
      BlankColumn = Yes
      for y = 1 to FontHeight - 1

        if BMleft(Chr) = 0
          Position = (y * FontWidth * 4) + (x * 4) + 15
          Alpha = memblock byte(TrimMemblock, Position)

          if Alpha > 0
            BlankColumn = No
            y = FontHeight - 1
          endif
        endif

      next y

      if BlankColumn = No
        BMleft(Chr) = x / 2
        x = FontWidth
      endif

    next x

    for x = FontWidth - 1 to 1 step - 1
      BlankColumn = Yes
      for y = 1 to FontHeight - 1

        if BMwidth(Chr) = 0
          Position = (y * FontWidth * 4) + (x * 4) + 15
          Alpha = memblock byte(TrimMemblock, Position)

          if Alpha > 0
            BlankColumn = No
            y = FontHeight
          endif
        endif

      next y

      if BlankColumn = No
        BMwidth(Chr) = (x - BMleft(Chr)) / 2
        x = 1
      endif

    next x
    delete memblock TrimMemblock

  next Chr

  BMleft(32) = 0
  BMwidth(32) = FontWidth / 4

endfunction

`*********************************
`      DISPLAY BITMAP FONT
`*********************************
Function BMFont(X,Y,S as string, TextNo,Kern)

  if len(S) > chars
    chars = len(S)
    dim BMSprites(texts, chars) as dword
  endif

  for k = 1 to len(S)
    Chr = asc(mid$(S,k))

    if BMSprites(TextNo, k) = 0 then BMSprites(TextNo, k) = free_spr()

    if k > 1
      sprite BMSprites(TextNo, k),NewX - BMleft(Chr) ,Y ,FontImageNumber(Chr)
      NewX = (NewX) + BMwidth(Chr) + Kern
    else
      sprite BMSprites(TextNo, k),X - BMleft(Chr) ,Y ,FontImageNumber(Chr)
      NewX = X + BMwidth(Chr) + Kern
    endif
    
    scale sprite BMSprites(TextNo, k), 50

  next k

endfunction

function NewText()

  inc texts
  dim BMSprites(texts, chars) as dword

endfunction texts

function DeleteTexts()

  local x as dword
  local y as dword
  
  if chars < 0 or texts < 0 then exitfunction
  
  for x = 0 to chars
    for y = 0 to texts
      if BMSprites(x, y) then delete sprite BMSprites(x, y)
    next y
  next x
  
  empty array BMSprites(x, y)
  texts = -1
  chars = -1
  
endfunction